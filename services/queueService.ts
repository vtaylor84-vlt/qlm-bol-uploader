import { openDB, IDBPDatabase } from 'idb';
import { QueuedSubmission, LoadSubmission } from '../types';
import { uploadSubmission } from './uploadService';

const DB_NAME = 'QLMQueueDB';
const STORE_NAME = 'submissions';
const DB_VERSION = 1;
const RETRY_DELAY = 10000; // 10 seconds

let dbPromise: Promise<IDBPDatabase<unknown>> | null = null;
let isProcessing = false;

const initDB = async () => {
    if (!dbPromise) {
        dbPromise = openDB(DB_NAME, DB_VERSION, {
            upgrade(db) {
                db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
            },
        });
    }
    return dbPromise;
};

// --- API ---

/**
 * Saves a new submission to the IndexedDB queue.
 * @param submission The complete LoadSubmission object.
 */
export const saveSubmissionToQueue = async (submission: LoadSubmission): Promise<void> => {
    const db = await initDB();
    
    // Separate Blobs (files) from metadata for IndexedDB storage
    const metadata: Omit<LoadSubmission, 'files'> & { fileIds: string[] } = {
        ...submission,
        files: [], // Remove file objects from metadata
    };
    
    const fileBlobs = submission.files.map(sf => ({
        id: sf.id,
        content: sf.file,
        fileName: sf.file.name,
        fileType: sf.file.type,
    }));
    
    const queuedItem: QueuedSubmission = {
        data: metadata,
        files: fileBlobs,
        status: 'pending',
        attemptCount: 0,
        timestamp: Date.now(),
        // id will be auto-generated by IndexedDB
    };

    await db.add(STORE_NAME, queuedItem);
    console.log(`[QUEUE] Submission ${submission.submissionId} saved to IndexedDB.`);
    // Immediately trigger processing after saving
    processQueue();
};

/**
 * Retrieves all pending submissions from the queue.
 */
const getPendingSubmissions = async (): Promise<QueuedSubmission[]> => {
    const db = await initDB();
    return db.getAll(STORE_NAME);
};

/**
 * Removes a successfully uploaded submission from the queue.
 * @param id The IndexedDB key of the submission.
 */
const removeSubmissionFromQueue = async (id: number): Promise<void> => {
    const db = await initDB();
    await db.delete(STORE_NAME, id);
    console.log(`[QUEUE] Submission ID ${id} removed from queue.`);
};

/**
 * Main function to process the queue in the background.
 */
export const processQueue = async (): Promise<void> => {
    if (isProcessing) return;
    isProcessing = true;
    console.log("[QUEUE] Starting queue processing...");

    const submissions = await getPendingSubmissions();

    for (const submission of submissions) {
        if (!navigator.onLine) {
            console.log("[QUEUE] Connection lost. Stopping queue processing.");
            isProcessing = false;
            return;
        }

        try {
            await uploadSubmission(submission);
            await removeSubmissionFromQueue(submission.id!);
            // Give a moment for the next attempt
            await new Promise(r => setTimeout(r, 500)); 
        } catch (error) {
            console.error(`[QUEUE] Failed to upload submission ${submission.id}. Retrying later.`, error);
            // In a real app, you would increment attemptCount and perhaps apply an exponential backoff time.
            // For now, we leave it in the queue for the next cycle.
            await new Promise(r => setTimeout(r, 500)); // Non-blocking pause
        }
    }

    isProcessing = false;
    console.log("[QUEUE] Queue processing finished.");

    // Set a timeout to check the queue again, ensuring offline-first
    if (submissions.length > 0) {
        setTimeout(processQueue, RETRY_DELAY); 
    }
};

// Start the queue processor on connection recovery/initial load
window.addEventListener('online', processQueue);

// Initial check (in case the app is loaded while online)
initDB().then(processQueue);